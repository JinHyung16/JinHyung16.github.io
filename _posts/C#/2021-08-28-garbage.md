---
layout: tag
title: "garbage_collection story(01)"
categories:
- Csharp
tag:
- Csharp
---
## Study about garbage collection

- 가비지 컬렉션은 자동 메모리 관리를 해줌
- CLR 내에서 가비지 컬렉터가 가비지 컬렉션을 담당함
- 가비지 컬렉터도 소프트웨어로 컴퓨팅 자원을 사용함

>CLR에서 메모리에 객체 할당 방법

- 관리되는 힙을 위한 메모리 공간 확보
- 확보한 공간 첫 번째 공간에 다음 객체를 할당할 메모리의 포인터를 넣는다.
- 값 형식의 객체는 스택에 할당되어 코드블럭이 끝나면 메모리 소멸
- 참조 형식의 객체는 힙에 할당되어 코드블럭에 상관없이 존재

```csharp
static void Main(string[] args)
{
    if(true)
    {
        object a = new object();
    }
}
```

- if 블로내 참조 a 메모리가 있고 객체화 a는 힙에 저장되어 있다.
- if문이 끝나면 스택 a 메모리가 소멸되어 힙에 저장된 객체 a의 접근 못하는 쓰레기가 됨
- 이런 쓰레기를 가비지 컬렉터가 수거해감

>세대별 가비지 컬렉션

- CLR은 메모리를 3개의 세대로 관리
- 0세대는 가비지 컬렉션을 한번도 겪지 않은 갓 생성된 객체
- 2세대는 최소 2회이상 가비지 컬렉션을 겪고도 살아남은 객체
- 1세대는 0세대에서 2세대로 넘어가는 과도기의 객체
- 가비지 컬렉션의 빈도느 2세대<1세대<0세대

>Full GC

- 2세대 힙이 가득 차는 경우로
- CLR에서 애플리케이션 실행을 일시 중단함
- 0~2세대 전체 메모리에 걸쳐 쓰레기를 수집
- 애플리케이션이 차지하는 메모리가 클수록 장시간 실행을 중지한다.

>GC를 최소화 하는 가이드라인

- 객체를 너무 많이 할당 X 왜냐 관리되는 힙의 각 세대에 메모리 포화를 초래해 빈번한 가비지 컬렉션 호출됨
- 너무 큰 객체 할당 피하기 왜냐 85KB 이상 객체를 할당하는 대형 객체 힙(LOH)과 소형 객체 힙(SOH)이 있는데 LOH는 할당 시의 성능과 메모리 공간 효율이 좋지 않고 2세대 힙으로 간주하여 전 세대에 가비지 컬렉션 촉발시켜 FULL GC 발생
- 너무 복잡한 참조 관계 만들지 X 왜냐 참조 관계가 많은 객체는 가비지 컬렉션후 살아남았을때 객체의 각 필드 간 참조 관계를 모두 조사해 참조하는 메모리 주소 모두 수정하고 가비지 컬렉션을 회피하기 위해 오버헤드가 큰 write barrier 생성 문제가 생김
- 루트를 너무 많이 만들지 X 왜냐 루트 목록이 작을수록 컬렉터 검사 횟수가 줄어 가비지 컬렉션을 더 빨리 끝내기 때문