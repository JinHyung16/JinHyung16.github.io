---
layout: tag
title: "class story(01)"
categories:
- Csharp
tag:
- Csharp
---

## Study about csharp object oriented

- 객체지향의 더 자세한 내용은 C++ 카테고리를 공부하면 도움됨

>class?

- 객체를 만들기위해 사용하는것
- Data - 속성
- Method - 기능

>생성자와 종료자(소멸자)

- 생성자는 클래스와 같은 이름으로 반환형식이 없다.
- 기본생성자와 사용자 지정 생성자가있다
- 종료자는 매개변수도없고 한정자도 사용하지 않으며 오버로딩 불가능하고 직접 호출할 수 없다.
- 종료자는 CLR의 가비지 컬렉터가 객체 소멸시점을 판단해 호출한다.
- 종료자는 가급적 구현안하는걸 추천

```csharp
class JinHyung
{
    public JinHyung() {} // 기본 생성자
    public JinHyung(int age, float weight) {} // 사용자 지정 생성자
    ~JinHyung() {} // 종료자
}
```

>static field and method

- static은 메소드나 필드가 클래스 자체에 속하도록 지정하는 한정자
- 인스턴스 소속 필드 vs 클래스 소속 필드
- 필드는 C++에서 멤버라고 생각

```csharp
// 1번
class MyClass_Instance
{
    public int a;
}
public static void Main()
{
    MyClass mc = new MyClass();
    mc.a = 1;
}

// 2번
class MyClass_class
{
    public static int a;
}
public static void Main()
{
    MyClass_class.a = 1;
}
```

- 1번은 인스턴스 소속필드 2번은 클래스 소속 필드다.
- 2번의 경우 인스턴스를 만들지 않고 클래스의 이름을 통해 필드에 직접 접근한다.

>static field and static method

- 정적 메소드는 클래스 자체에 소속된다
- 클래스 인스턴스 생성 없이도 호출 가능

```csharp
class MyClass_staitc
{
    public static void StaticMethod()
    {
        Console.WriteLine("static_metohd");
    }
}
class MyClass_instance
{
    public void InstanceMethod()
    {
        Console.WriteLine("instance_method");
    }
}
public static void Main()
{
    // 1번
    MyClass_static m_st.StaticMethod();

    // 2번
    MyClass_instance m_in = new MyClass_insatnce();
    m_in.InstanceMethod();
}
```

- 1번은 정적 메소드 호출 2번은 인스턴스 메소드 호출방법이다.

>Shallow copy & Deep copy

- 얕은 복사는 객체 복사시 참조만 살짝 복사
- 깊은 복사는 별도의 힙 공간에 객체 자체 복사

>this

- 객체가 자신을 지칭할때 사용하는 키워드
- 객체 내부에서 자신의 필드나 메소드에 접근시 사용
- 아래 두 예제코드로 비교하기

```csharp
class MyClass
{
    int a, b, c;
    public MyClass()
    {
        this.a = 1;
    }
    public MyClass(int b)
    {
        this.a = 1;
        this.b = b;
    }
    public MyClass(int b, int c)
    {
        this.a = 1;
        this.b = b;
        this.c = c;
    }
}
```

- 만약 사용자 지정생정자를 이와같이 생성하고 a값에는 늘 고정된 값을 부르고 싶을때 this를 이용하면 좋다

```csharp
class MyClass
{
    int a, b, c;
    public MyClass()
    {
        this.a = 1;
    }
    public MyClass(int b) : this()
    {
        this.b = b;
    }
    public MyClass(int b, int c) : this(b)
    {
        this.c = c;
    }
}
```

- this(b)를 통해 MyClass(int b)를 호출 this()를 통해 기본생성자를 호출하여 위 클래스 예제보다 더 간결해진다.

>접근한정자

- 은닉성(캡슐화)의 구현할때 이용한다.

>inheritance & 'base' keyword

- 기반 클래스와 파생 클래스 사이에 형식 변환이 가능하다.
- is / as 키워드가 형 변환 연산자로 as는 참조형식에만 사용한다.
- 파생 클래스의 수명주기는 다음과 같다

```csharp
class Base
{
    protected int Age;
    // 1
    public Base() { Console.WriteLine("Base()"); }
    // 4
    ~Base() { Console.WriteLine("~Base()"); }

    public void BaseMethod() {}
    public Base(int age)
    {
        this.Age = age;
    }
}
class Derived : Base
{
    // 2
    public Derived() { Console.WriteLine("Derived()"); }
    // 3
    ~Derived() { Console.WriteLine("~Derived()"); }

    public void DerivedMethod()
    {
        base.BaseMethod();
    }
    public Derived(int age) : base(Age)
    {
        Console.WriteLine("(0).Derived()", this.Age);
    }
}
```

- 위에 써놓은 숫자 순서대로 기반클래스의 생성자 파생클래스의 생성자 파생클래스의 종류자 기반클래스의 종료자 순으로 호출된다

- base 키워드 사용하면 기반 클래스의 접근가능하며 파생 클래스의 생성자에서 기반 클래스의 생성자에 매개변수 전달도 가능하다.
