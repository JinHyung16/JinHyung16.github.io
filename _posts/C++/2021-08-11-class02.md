---
layout: tag
title:  "class story_C++"
---

## Preview

- class 01에서 class는 [구조체+함수]와 유사하했다. <br>
- 사실 여기에 부가적으로 알파가 추가되어야한다. <br>
- 알파에는 접근제어자+상속 등등이 있다. <br>
- class와 구조체(struct) 멤버에는 Data와 Function이 있다 <br>
- class에서 Function을 Method라고 부른다 <br>

## 접근제어

class를 통해 Object(객체)를 구현할수있다. 여기서 중요한건 객체의 내부와 외부가 있음을 기억! <br>
외부에서 내부로 접근하는걸 통제하는게 필요 -> Why? 문제가 생길수있으니깐... 그리고 다 public처럼 사용가능하면 class의 기능을 잃는다 <br>

## 생성자 / 소멸자

대다수의 객체지향적 언어에선 class <- [생성자/소멸자]를 제공하며 [생성자/소멸자]는 함수다

- 호출시점 특정할수없다 -> 자동으로 호출(문법에 따라 언제, 왜... 이미 정해짐) => programmer가 이에 개입하여 수정이 불가
- 반환이 없다
>C++ 생성자 test 코드
```생성자
class CTest
{
public:
  CTest()
  {
    std::cout << "CTests()" << std::endl;
  }
};

CTest b;

int main(void)
{
  std::cout << "Begin of main()" << std::endl;
  CTest a;
  return 0;
}
```
위 test코드를 실행해보면 CTest b -> main -> CTest a 순서대로 호출됨을 알 수 있다 <br>
C 에선 main()이 시작점이였다면 C++에선 그렇지않음을 기억하자 <br>
>C++ 소멸자 test 코드
```소멸자
class CTest
{
public:
  CTest()
  {
    std::cout << "CTests()" << std::endl;
  }
  ~CTest()
  {
    std::cout << "~CTests()" << std::endl;
  }
};

int main(void)
{
  std::cout << "Begin of main()" << std::endl;
  CTest a;
  std::cout << "End of main()" << std::endl;
  return 0;
}
```
위 test코드를 실행시켜보면 Begin -> CTest -> End -> ~CTest 순으로 실행된다 <br>
이를 통해 main의 스코프가 닫히는 시점이 지역변수의 소멸시점인데 이 때 모든 소멸자가 call됨을 기억하자 <br>

### new/delete
>new/delete VS malloc/free
```C malloc/free 예시
class CTest
{
public:
  CTest()
  {
    std::cout << "CTests()" << std::endl;
  }
  ~CTest()
  {
    std::cout << "~CTests()" << std::endl;
  }
};

int main(void)
{
  CTest *pTest = (CTest*)malloc(sizeof(CTest));
  free(pTest);
  
  CTest *pNewTest = new CTest;
  delete pNewTest;
  return 0;
}
```
실행시켜보면 생성자가 안불린다 왜냐 pTest가 가리키는건 CTest 데이터가 들어갈수있는 메모리인거지 CTest가 아니기 때문이다 <br>
그러나 아래 pNewTest는 생성자와 소멸자를 호출한다 <br>
즉 new/delete는 "그 인스턴스냐" malloc/free는 "그 인스턴스를 담을수있을정도에 충분한 메모리 크기냐" 를 의미하니 다른걸 기억하자 <br>
