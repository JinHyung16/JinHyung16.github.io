## Study C++ about class
### this 포인터
>이해를 위한 메모리주소 찍기
```this 포인터이해
class CTest
{
public:
  CTest()
  {
    //std::cout << "CTests()" << std::endl;
  }
  ~CTest()
  {
    //std::cout << "~CTests()" << std::endl;
  }
  void PrintData()
  {
    std::cout << m_Data << std::endl;
  }
protected:
  int m_Data = 0;
};

int main(void)
{
  CTest a;
  std::cout << &a << std::endl;
  
  CTest b;
  std::cout << &b << std::endl;
  return 0;
}
```
실행시 Instance 된 a 와 b의 주소는 각각 다르게 나온다 <br>
그렇다면 CTest의 멤버인 m_Data를 출력하는 PrintData() 호출 시 a.PrintData() 와 b.PrintData()도 다를까? <br>
class_01을 참고하면 a.PrintData(&a)를 작성한적이있다 <br>
현재 CTest의 PrintData()는 parameter를 넘기는게 없지만 실제로 작동시 위와 같이 a.PrintData(&a)/b.PrintData(&b) 이렇게 넘긴다 <br>
>this 이해를 돕기위한 추가코드
```this를 찍어보자
class CTest
{
public:
  CTest()
  {
    //std::cout << "CTests()" << std::endl;
  }
  ~CTest()
  {
    //std::cout << "~CTests()" << std::endl;
  }
  void PrintData()
  {
    std::cout << this << std::endl;
    std::cout << m_Data << std::endl;
    std::cout << this->m_Data<<std::endl;
  }
protected:
  int m_Data = 0;
};

int main(void)
{
  CTest a;
  std::cout << &a << std::endl;
  a.PrintData();
  
  CTest b;
  std::cout << &b << std::endl;
  b.PrintData();
  return 0;
}
```
출력해보면 a b 의 주소값밑에 같은 주소값이 찍히는데 그게 this의 출력결과다 <br>
즉 위에서 말한것처럼 hidden parameter(a.PrintData(&a)/b.PrintData(&b) 이런 형태로)가 넘어감을 알수있다 <br>
this 포인터의 값은 자동으로 결정됨 -> programmer가 개입을 할수없음 <br>

## 정적멤버 (static)
정적멤버는 [전역변수, 전역함수]를 만드는 방법이라 생각!! <br>
정적멤버는 Instance 와 관련이 없다 <br>
>정적 Data(변수)는 동시성 문제를 야기 -> Multithreading... 등등의 문제생김 -> 더 깊은 내용은 운영체제공부!! <
>전역 함수와 변수를 남발하면 객체지향 개념과 상관없는 코드로 변질될 가능성이 커짐
